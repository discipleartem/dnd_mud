# Архитектура проекта после рефакторинга

## Обзор

Проект рефакторен согласно принципам **Чистой Архитектуры** (Clean Architecture) с соблюдением стандартов PEP8 и лучших практик Python.

## Структура слоев

```
src/
├── entities/           # Слой сущностей (бизнес-логика)
├── interfaces/         # Слой интерфейсов (абстракции)
├── use_cases/         # Слой сценариев использования
├── frameworks/        # Слой фреймворков (реализации)
├── ui/               # Слой интерфейсов (адаптеры)
└── di_container.py    # Контейнер внедрения зависимостей
```

## Принципы чистой архитектуры

### 1. Правило зависимостей
- **Внешние слои → Внутренние слои**
- UI/Controllers → Use Cases → Entities
- Frameworks → Interfaces → Business Rules

### 2. Независимость слоев
- **Entities** не зависят от UI, базы данных, внешних сервисов
- **Use Cases** зависят только от Entities и Interfaces
- **Interface Adapters** зависят от Use Cases и Entities
- **Frameworks & Drivers** зависят от всех внутренних слоев

## Слой Entities (`src/entities/`)

**Назначение:** Бизнес-правила и сущности предприятия  
**Зависимости:** Никаких внешних зависимостей

### Файлы:
- `character.py` - Сущности персонажа (Character, CharacterData, Ability)
- `exceptions.py` - Исключения бизнес-логики

### Ключевые принципы:
- Чистая бизнес-логика без внешних зависимостей
- Инкапсуляция правил предметной области
- Методы с бизнес-значимыми операциями (take_damage, heal, is_alive)

## Слой Interfaces (`src/interfaces/`)

**Назначение:** Определение интерфейсов для репозиториев и внешних сервисов  
**Зависимости:** Только от Entities

### Файлы:
- `repositories.py` - Интерфейсы репозиториев

### Ключевые принципы:
- Абстрактные классы с контрактами
- Зависимость от абстракций, а не реализаций
- Чистые интерфейсы без имплементации

## Слой Use Cases (`src/use_cases/`)

**Назначение:** Правила приложения и сценарии использования  
**Зависимости:** Только от Entities и Interfaces

### Файлы:
- `character_creation.py` - Use Cases для создания персонажа

### Ключевые принципы:
- Оркестрация бизнес-процессов
- Валидация бизнес-правил
- Преобразование данных между слоями
- Инъекция зависимостей через конструктор

## Слой Frameworks (`src/frameworks/`)

**Назначение:** Внешние интерфейсы (Web, Database, External APIs)  
**Зависимости:** Все внутренние слои

### Файлы:
- `repositories.py` - Реализации репозиториев (YAML, In-memory)
- `ability_generator.py` - Генератор характеристик
- `size_repository.py` - Репозиторий размеров

### Ключевые принципы:
- Конкретные реализации интерфейсов
- Работа с внешними технологиями (YAML, файловая система)
- Изоляция внешних зависимостей

## Слой UI (`src/ui/`)

**Назначение:** Адаптеры интерфейсов, преобразование данных  
**Зависимости:** Use Cases и Entities

### Файлы:
- `character_controller.py` - Контроллер (Interface Adapter)
- `character_creator_clean.py` - UI создателя персонажей
- `main_menu_clean.py` - Главное меню
- `user_choice.py` - Утилиты пользовательского ввода

### Ключевые принципы:
- Преобразование данных между UI и Use Cases
- Обработка пользовательского взаимодействия
- Делегирование бизнес-логики в Use Cases

## Внедрение зависимостей (`src/di_container.py`)

**Назначение:** Управление зависимостями и создание объектов  
**Паттерн:** Dependency Injection + Factory + Singleton

### Ключевые принципы:
- Ленивая инициализация объектов
- Централизованное управление зависимостями
- Типобезопасность
- Изоляция от конкретных реализаций

## Примененные паттерны проектирования

1. **Repository** - Инкапсуляция доступа к данным
2. **Dependency Injection** - Внедрение зависимостей через конструктор
3. **Factory** - Создание объектов в DI контейнере
4. **Singleton** - Глобальный контейнер зависимостей
5. **Interface Adapter** - Преобразование данных между слоями
6. **Use Case** - Оркестрация бизнес-процессов

## Соответствие принципам Python

### PEP8
- ✅ Правильное именование (snake_case для функций/переменных)
- ✅ Длина строк ≤ 79 символов
- ✅ Правильная группировка импортов
- ✅ Type hints везде

### Zen of Python
- ✅ Explicit is better than implicit (явные зависимости)
- ✅ Simple is better than complex (чистая архитектура)
- ✅ Readability counts (понятная структура)
- ✅ Errors should never pass silently (обработка исключений)

### SOLID принципы
- ✅ **S**ingle Responsibility - каждый класс имеет одну ответственность
- ✅ **O**pen/Closed - открыт для расширения, закрыт для изменения
- ✅ **L**iskov Substitution - подклассы заменяют базовые классы
- ✅ **I**nterface Segregation - маленькие, сфокусированные интерфейсы
- ✅ **D**ependency Inversion - зависимость от абстракций

## Преимущества новой архитектуры

1. **Тестируемость** - Легкое мокирование зависимостей
2. **Гибкость** - Простая замена реализаций
3. **Поддерживаемость** - Чёткое разделение ответственности
4. **Масштабируемость** - Добавление новой функциональности без изменения существующего кода
5. **Изоляция** - Бизнес-логика не зависит от внешних факторов

## Использование

```python
from src.di_container import get_character_creator

# Получить создатель персонажей со всеми зависимостями
character_creator = get_character_creator()

# Создать персонажа
character = character_creator.create_character()
```

Все зависимости автоматически внедряются через DI контейнер, обеспечивая чистоту архитектуры и простоту использования.